\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[]{article}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}

% settings
\usepackage{minted}
%



\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provides euro and other symbols
\else % if luatex or xelatex
  \usepackage{unicode-math}
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
    \setmainfont[]{Source Han Serif CN}
    \setsansfont[]{Source Han Sans CN}
    \setmonofont[Mapping=tex-ansi]{Source Code Pro}
  \ifxetex
    \usepackage{xeCJK}
    \setCJKmainfont[]{Source Han Serif CN}
  \fi
  \ifluatex
    \usepackage[]{luatexja-fontspec}
    \setmainjfont[]{Source Han Serif CN}
  \fi
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage[margin=2cm]{geometry}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{0}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi


% set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother

\usepackage{minted}



\date{}

\title{\vspace{50mm} \huge Code Template \\[20pt]}
\author{There is no gay @ CCNUACM \\[10pt] Central China Normal University}
\date{\today}


\begin{document}

\begin{titlepage}

\maketitle

\end{titlepage}

\newpage

\renewcommand\labelitemi{$\bullet$}

{
\setcounter{tocdepth}{3}
\tableofcontents
\newpage
}








\hypertarget{ux6742ux9879}{%
\section{0-æ‚é¡¹}\label{ux6742ux9879}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ux5febux8bfb}{%
\subsection{å¿«è¯»}\label{ux5febux8bfb}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
inline int read()
{
    int x = 0, w = 1;
    char ch = 0;
    while (ch < '0' || ch > '9')
    {
        ch = getchar();
        if (ch == '-')
        {
            w = -1;
        }
    }
    while (ch >= '0' && ch <= '9')
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    }
    return x * w;
}
\end{minted}

\hypertarget{judge.sh}{%
\subsection{\texorpdfstring{\texttt{judge.sh}}{judge.sh}}\label{judge.sh}}

Assume using directory ``./contest''.

\begin{verbatim}
../contest:
a.cpp  b.cpp  samples-a  samples-b  judge.sh

../contest/samples-a:
1.ans  1.in

../contest/samples-b:
1.ans  1.in  2.ans  2.in
\end{verbatim}

\texttt{judge.sh}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{bash}
#!bin/bash
set -e
[ $# == 2 ] || { echo invalid args ; exit 1 ; }
g++ $2.cpp || { echo CE ; exit 1 ; }
src=./samples-$1
dir=$1-test
mkdir -p $dir
cp $src/* $dir/ 
cd $dir
mv ../a.out ./$2
for input in *.in; do
  [ $input == "*.in" ] && exit 0
  cas=${input%.in}
  output=$cas.out
  answer=$cas.ans
  timeout 1 ./$2 < $input > $output 2> $cas.err || { echo Case $cas : TLE or RE ; continue ; }
  if diff -Za $output $answer > $cas.dif ; then
    echo Case $cas : AC
  else
    echo Case $cas : WA
    cat $cas.dif $cas.err
  fi
done
\end{minted}

command:

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{bash}
cd ./contest
bash judge.sh a a.cpp
\end{minted}

\hypertarget{ux5fc3ux6001ux5d29ux4e86}{%
\subsection{å¿ƒæ€å´©äº†}\label{ux5fc3ux6001ux5d29ux4e86}}

\begin{itemize}
\tightlist
\item
  \texttt{(int)v.size()}
\item
  \texttt{1LL\ \textless{}\textless{}\ k}
\item
  é€’å½’å‡½æ•°ç”¨å…¨å±€æˆ–è€… static å˜é‡è¦å°å¿ƒ
\item
  é¢„å¤„ç†ç»„åˆæ•°æ³¨æ„ä¸Šé™
\item
  æƒ³æ¸…æ¥šåˆ°åº•æ˜¯è¦ \texttt{multiset} è¿˜æ˜¯ \texttt{set}
\item
  æäº¤ä¹‹å‰çœ‹ä¸€ä¸‹æ•°æ®èŒƒå›´ï¼Œæµ‹ä¸€ä¸‹è¾¹ç•Œ
\item
  æ•°æ®ç»“æ„æ³¨æ„æ•°ç»„å¤§å° ï¼ˆ2å€ï¼Œ4å€ï¼‰
\item
  å­—ç¬¦ä¸²æ³¨æ„å­—ç¬¦é›†
\item
  å¦‚æœå‡½æ•°ä¸­ä½¿ç”¨äº†é»˜è®¤å‚æ•°çš„è¯ï¼Œæ³¨æ„è°ƒç”¨æ—¶çš„å‚æ•°ä¸ªæ•°ã€‚
\item
  æ³¨æ„è¦è¯»å®Œ
\item
  æ„é€ å‚æ•°æ— æ³•ä½¿ç”¨è‡ªå·±
\item
  æ ‘é“¾å‰–åˆ†/dfs åºï¼Œåˆå§‹åŒ–æˆ–è€…è¯¢é—®ä¸è¦å¿˜è®° idx, ridx
\item
  æ’åºæ—¶æ³¨æ„ç»“æ„ä½“çš„æ‰€æœ‰å±æ€§æ˜¯ä¸æ˜¯è€ƒè™‘äº†
\item
  ä¸è¦æŠŠ while å†™æˆ if
\item
  ä¸è¦æŠŠ int å¼€æˆ char
\item
  æ¸…é›¶çš„æ—¶å€™å…¨éƒ¨ç”¨ 0\textasciitilde n+1ã€‚
\item
  æ¨¡æ„ä¹‰ä¸‹ä¸è¦ç”¨é™¤æ³•
\item
  å“ˆå¸Œä¸è¦è‡ªç„¶æº¢å‡º
\item
  æœ€çŸ­è·¯ä¸è¦ SPFAï¼Œä¹–ä¹–å†™ Dijkstra
\item
  ä¸Šå–æ•´ä»¥åŠ GCD å°å¿ƒè´Ÿæ•°
\item
  mid ç”¨ \texttt{l\ +\ (r\ -\ l)\ /\ 2} å¯ä»¥é¿å…æº¢å‡ºå’Œè´Ÿæ•°çš„é—®é¢˜
\item
  å°å¿ƒæ¨¡æ¿è‡ªå¸¦çš„æ„æ–™ä¹‹å¤–çš„éšå¼ç±»å‹è½¬æ¢
\item
  æ±‚æœ€ä¼˜è§£æ—¶ä¸è¦å¿˜è®°æ›´æ–°å½“å‰æœ€ä¼˜è§£
\item
  å›¾è®ºé—®é¢˜ä¸€å®šè¦æ³¨æ„å›¾ä¸è¿é€šçš„é—®é¢˜
\item
  å¤„ç†å¼ºåˆ¶åœ¨çº¿çš„æ—¶å€™ lastans è´Ÿæ•°ä¹Ÿè¦è®°å¾—çŸ«æ­£
\item
  ä¸è¦è§‰å¾—ç¼–è¯‘å™¨ä»€ä¹ˆéƒ½èƒ½ä¼˜åŒ–
\item
  åˆ†å—ä¸€å®šè¦ç‰¹åˆ¤åœ¨åŒä¸€å—ä¸­çš„æƒ…å†µ
\end{itemize}

\hypertarget{sol.cpp}{%
\subsection{sol.cpp}\label{sol.cpp}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using VI = vector<ll>;
using PII = pair<int, int>;
template <typename T> using fc = function<T>;
using Graph = vector<vector<int>>;
#define pb push_back
#define debug(c) cerr << #c << " = " << c << endl;
#define rg(x) x.begin(), x.end()
#define rep(a, b, c) for (auto a = (b); (a) < (c); a++)
#define repe(a, b, c) for (auto a = (b); (a) <= (c); a++)
const int MOD = 998244353;
const int N = 0;
#ifdef ONLINE_JUDGE
#define cerr assert(false);
#endif

void solve()
{
    
}

int main()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T = 1;
    cin >> T;
    while (T--)
        solve();

    return 0;
}
\end{minted}

\hypertarget{ux4e09ux5206}{%
\subsection{ä¸‰åˆ†}\label{ux4e09ux5206}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
double cal()
{
    double l = 0, r = 1e10;
    for (int i = 1; i <= 100; i++)
    {
        double m1 = l + (r - l) / 3;
        double m2 = (r - l) / 3 * 2 + l;
        if (f(m1) < f(m2))
            l = m1;
        else
            r = m2;
    } // æ±‚æœ€å¤§å€¼
    return f(l);
}

int cal()
{
    int l = 0, r = 1e10;
    while (l + 2 < r)
    {
        int m1 = l + (r - l) / 3;
        int m2 = (r - l) / 3 * 2 + l;
        if (f(m1) < f(m2))
        {
            l = m1;
        }
        else
        {
            r = m2;
        }
    }
    int ans = f(l);
    for (int i = l + 1; i <= r; i++)
    {
        ans = max(ans, f(i));
    }
}
\end{minted}

\hypertarget{ux5b57ux7b26ux4e32}{%
\section{1-å­—ç¬¦ä¸²}\label{ux5b57ux7b26ux4e32}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{kmp}{%
\subsection{KMP}\label{kmp}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int f[N];
void kmp(string s, string p)
{
    p += '@';
    p += s;
    for (int i = 1; i < p.size(); i++)
    {
        int j = f[i - 1];
        while (j && p[j] != p[i])
            j = f[j - 1];
        if (p[j] == p[i])
            f[i] = j + 1;
    }
}
\end{minted}

\hypertarget{manacher}{%
\subsection{Manacher}\label{manacher}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <cstdio>
using namespace std;
using ll = long long;
// !!! N = n * 2, because you need to insert '#' !!!
const int N = 3e7;
#define min(A, B) ((A > B) ? B : A)
// p[i]: range of the palindrome i-centered. 
int p[N];
// s: the string.
char s[N] = "@#";
// l: length of s.
int l = 2;

int main()
{
    char tmp = getchar();
    while (tmp > 'z' || tmp < 'a')
        tmp = getchar();
    while (tmp <= 'z' && tmp >= 'a')
        s[l++] = tmp, s[l++] = '#', tmp = getchar();
    /*<--- input & preparation --->*/
    int m = 0, r = 0;
    ll ans = 0;
    for (int i = 1; i < l; i++)
    {
        // evaluate p[i]
        if (i <= r)
            p[i] = min(p[m * 2 - i], r - i + 1);
        else
            p[i] = 1;
        // brute force!
        while (s[i - p[i]] == s[i + p[i]])
            ++p[i];
        // maintain m, r
        if (i + p[i] > r)
        {
            r = i + p[i] - 1;
            m = i;
        }
        // find the longest p[i]
        if (p[i] > ans)
            ans = p[i]; 
    }
    printf("%lld", ans - 1);

    return 0;
}
    
\end{minted}

\hypertarget{hash}{%
\subsection{hash}\label{hash}}

\hypertarget{ux968fux673aux7d20ux6570ux8868}{%
\subsubsection{éšæœºç´ æ•°è¡¨}\label{ux968fux673aux7d20ux6570ux8868}}

42737, 46411, 50101, 52627, 54577, 191677, 194869, 210407, 221831,
241337, 578603, 625409, 713569, 788813, 862481, 2174729, 2326673,
2688877, 2779417, 3133583, 4489747, 6697841, 6791471, 6878533, 7883129,
9124553, 10415371, 11134633, 12214801, 15589333, 17148757, 17997457,
20278487, 27256133, 28678757, 38206199, 41337119, 47422547, 48543479,
52834961, 76993291, 85852231, 95217823, 108755593, 132972461, 171863609,
173629837, 176939899, 207808351, 227218703, 306112619, 311809637,
322711981, 330806107, 345593317, 345887293, 362838523, 373523729,
394207349, 409580177, 437359931, 483577261, 490845269, 512059357,
534387017, 698987533, 764016151, 906097321, 914067307, 954169327

1572869, 3145739, 6291469, 12582917, 25165843, 50331653
ï¼ˆé€‚åˆå“ˆå¸Œçš„ç´ æ•°ï¼‰

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <string>
using ull = unsigned long long;
using std::string;
const int mod = 998244353;

int n;
ull Hash[2000200]; // è‡ªç„¶æº¢å‡ºæ³•ç”¨unsignedç±»å‹
ull RHash[2000200];
ull base[2000200];
void init()
{
    base[0] = 1;
    for (int i = 1; i <= 2000010; i++)
    {
        base[i] = base[i - 1] * 131 % mod;
    }
}
void get_hash(string s)
{
    for (int i = 1; i <= (int)s.size(); i++)
    {
        Hash[i] = Hash[i - 1] * base[1] % mod + s[i - 1];
        Hash[i] %= mod;
    }
}
void get_Rhash(string s)
{
    for (int i = (int)s.size(); i >= 1; i--)
    {
        RHash[s.size() - i + 1] = RHash[s.size() - i] * base[1] % mod + s[i - 1];
        RHash[i] %= mod;
    }
}
ull getR(int l, int r)
{
    if (l > r)
        return 0;
    return (RHash[r] - (RHash[l - 1] * base[r - l + 1]) % mod + mod) % mod;
}
ull get(int l, int r)
{
    if (l > r)
        return 0;
    return (Hash[r] - (Hash[l - 1] * base[r - l + 1]) % mod + mod) % mod;
}
\end{minted}

\hypertarget{ux5b57ux5178ux6811}{%
\subsection{å­—å…¸æ ‘}\label{ux5b57ux5178ux6811}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <string>
using std::string;
/* Last modified: 23/07/03 */
// Trie for string and prefix
class Trie
{

    static const int trie_tot_size = 1e5;
    // trie_node_size: modify if get() is modified.
    static const int trie_node_size = 64;
    int tot = 0;
    // end: reserved for count
    const int end = 63;
    int (*nxt)[trie_node_size];

  public:
    Trie()
    {
        nxt = new (int[trie_tot_size][trie_node_size]);
    }
    int get(char x)
    {
        // modify if x is in certain range, assuming 0-9 or a-z.
        if (x >= 'A' && x <= 'Z')
            return x - 'A';
        else if (x >= 'a' && x <= 'z')
            return x - 'a' + 26;
        else
            return x - '0' + 52;
    }
    int find(string s)
    {
        int cnt = 0;
        for (auto i : s)
        {
            cnt = nxt[cnt][get(i)];
            if (!cnt)
                return 0;
        }
        return cnt;
    }
    void insert(string s)
    {
        int cnt = 0;
        for (auto i : s)
        {
            auto j = get(i);
            // count how many strings went by
            nxt[cnt][end]++;
            if (nxt[cnt][j] > 0)
                // character i already exists.
                cnt = nxt[cnt][j];
            else
            {
                // doesn't exist, new node.
                nxt[cnt][j] = ++tot;
                cnt = tot;
            }
        }
        nxt[cnt][end]++;
    }
    int count(string s)
    {
        int cnt = find(s);
        if (!cnt)
            return 0;
        return nxt[cnt][end];
    }
    void clear()
    {
        for (int i = 0; i <= tot; i++)
            for (int j = 0; j <= end; j++)
                nxt[i][j] = 0;
        tot = 0;
    }
};
\end{minted}

\hypertarget{acux81eaux52a8ux673a}{%
\subsection{ACè‡ªåŠ¨æœº}\label{acux81eaux52a8ux673a}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <queue>
#include <string.h>
#include <string>
using std::string, std::queue;

struct AC_automaton
{
    static const int _N = 1e6;

    int (*trie)[27];
    int tot = 0;
    int *fail;
    int *e;
    AC_automaton()
    {
        trie = new int[_N][27];
        fail = new int[_N];
        e = new int[_N];
        memset(trie, 0, sizeof(trie));
        memset(fail, 0, sizeof(fail));
        memset(e, 0, sizeof(e));
    }

    void insert(string s)
    {
        int now = 0;
        for (auto i : s)
            if (trie[now][i - 'a'])
                now = trie[now][i - 'a'];
            else
                trie[now][i - 'a'] = ++tot, now = tot;
        e[now]++;
    }

    void build()
    {
        queue<int> q;
        for (int i = 0; i < 26; i++)
            if (trie[0][i])
                q.push(trie[0][i]);
        while (q.size())
        {
            int u = q.front();
            q.pop();
            for (int i = 0; i < 26; i++)
                if (trie[u][i])
                    fail[trie[u][i]] = trie[fail[u]][i], q.push(trie[u][i]);
                else
                    trie[u][i] = trie[fail[u]][i];
        }
    }

    int query(string t)
    {
        int u = 0, res = 0;
        for (auto c : t)
        {
            u = trie[u][c - 'a'];
            for (int j = u; j && e[j] != -1; j = fail[j])
                res += e[j], e[j] = -1;
        }
        return res;
    }
};

\end{minted}

\hypertarget{exkmp-z-function}{%
\subsection{exKMP (Z Function)}\label{exkmp-z-function}}

å¯¹\texttt{KMP}ä¸­\texttt{next}æ•°ç»„çš„å®šä¹‰ç¨ä½œæ”¹å˜ï¼Œå°±ä¼šå¾—åˆ°\texttt{exKMP}ã€‚

åœ¨\texttt{exKMP}ä¸­ï¼Œæˆ‘ä»¬è®°å½•\texttt{z{[}i{]}}ä¸ºï¼š\texttt{s{[}i:{]}} ä¸
\texttt{s} çš„æœ€é•¿å…¬å…±å‰ç¼€ã€‚

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
/// @brief Z function, or exKMP.
/// @param s the string.
/// @return the Z function array.
vector<int> Z_function(string &s, VI &z)
{
    // indexing from 1
    int len = s.size();
    s = "#" + s;
    // vector<int> z(len + 1);
    z[1] = 0;
    int l = 1, r = 1;
    for (int i = 2; i <= len; i++)
    {
        if (i <= r && z[i - l + 1] < r - i + 1)
            z[i] = z[i - l + 1];
        else
        {
            z[i] = std::max(0, r - i + 1);
            while (i + z[i] <= len && s[z[i] + 1] == s[i + z[i]])
                z[i]++;
        }
        if (i + z[i] - 1 > r)
        {
            l = i;
            r = i + z[i] - 1;
        }
    }
    z[1] = len;
    return z;
}
\end{minted}

\hypertarget{ux6570ux636eux7ed3ux6784}{%
\section{2-æ•°æ®ç»“æ„}\label{ux6570ux636eux7ed3ux6784}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ux6811ux72b6ux6570ux7ec4}{%
\subsection{æ ‘çŠ¶æ•°ç»„}\label{ux6811ux72b6ux6570ux7ec4}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
class BIT
{
    int n = 2e6;
    long long *a;

  public:
    BIT(int size) : n(size)
    {
        a = new long long[size + 10];
    }
    void update(int p, long long x)
    {
        while (p <= n)
            a[p] += x, p += (p & (-p));
    }

    long long query(int l, int r)
    {
        long long ret = 0;
        l--;
        while (r > 0)
            ret += a[r], r -= (r & (-r));
        while (l > 0)
            ret -= a[l], l -= (l & (-l));
        return ret;
    }
};

\end{minted}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
template<typename T>
struct Fenwick{
    int n;
    vector<T> tr;
 
    Fenwick(int n) : n(n), tr(n + 1, 0){}
 
    int lowbit(int x){
        return x & -x;
    }
 
    void modify(int x, T c){//å•ç‚¹æ·»åŠ 
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += c;
    }
 
    void modify(int l, int r, T c){//åŒºé—´æ·»åŠ 
        modify(l, c);
        if (r + 1 <= n) modify(r + 1, -c);
    }
 
    T query(int x){
        T res = T();
        for(int i = x; i; i -= lowbit(i)) res += tr[i];
        return res;
    }
 
    T query(int l, int r){
        return query(r) - query(l - 1);
    }
 
    int find_first(T sum){//å’Œå‡ºç°çš„ç¬¬ä¸€ä½ç½®
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] < sum){
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans + 1;
    }
 
    int find_last(T sum){
        int ans = 0; T val = 0;
        for(int i = __lg(n); i >= 0; i--){
            if ((ans | (1 << i)) <= n && val + tr[ans | (1 << i)] <= sum){
                ans |= 1 << i;
                val += tr[ans];
            }
        }
        return ans;
    }
 
};
using BIT = Fenwick<int>; 
\end{minted}

\hypertarget{ux5e76ux67e5ux96c6}{%
\subsection{å¹¶æŸ¥é›†}\label{ux5e76ux67e5ux96c6}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <cassert>
#include <iostream>
#include <set>
/* Last modified: 23/08/01 */
class DSU
{
  private:
    int *f;
    int size;

  public:
    DSU(int size) : size(size)
    {
        assert(size > 1);
        f = new int[size + 10];
        for (int i = 1; i <= size; i++)
            f[i] = i;
    }
    int find(int x)
    {
        return f[x] == x ? x : (f[x] = find(f[x]));
    };
    bool same(int x, int y)
    {
        return find(x) == find(y);
    };
    bool merge(int x, int y)
    {
        int fx = find(x), fy = find(y);
        return ((fx != fy) ? f[fx] = fy : false);
    };
    int count()
    {
        std::set<int> s;
        for (int i = 1; i <= size; i++)
            s.insert(find(i));
        return s.size();
    }
};
\end{minted}

\hypertarget{stux8868}{%
\subsection{STè¡¨}\label{stux8868}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
// log2(x) çš„é¢„å¤„ç†
// 1. é€’æ¨
lg[2] = 1;
for (int i = 3; i < N; i++)
    lg[i] = lg[i / 2] + 1;
// 2. åŸºäºç¼–è¯‘æœŸè®¡ç®—
using std::array;
// WARNING: LOG_SIZE may cause CE if too big.
const int LOG_SIZE = 1e5 + 10;
constexpr array<int, LOG_SIZE> LOG = []() {
    array<int, LOG_SIZE> l{0, 0, 1};
    for (int i = 3; i < LOG_SIZE; i++)
        l[i] = l[i / 2] + 1;
    return l;
}();
// 3. ç›´æ¥è®¡ç®—
int lg(int x)
{
    return 31 - __builtin_clz(x);
}
// STL æä¾›äº† std::lg(), åº•æ•°æ˜¯e.
\end{minted}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
class SparseTable
{
  private:
    // SIZE depends on range of f[i][0].
    // 22 is suitable for 1e5.
    static const int SIZE = 22;
    // f[i][j] maintains the result from i to i + 2 ^ j - 1;
    int (*f)[SIZE];
    using func = std::function<int(int, int)>;
    func op;
    // length of f from 1 to l;
    int l;

  public:
    SparseTable(int a[][SIZE], func foo, int len) : f(a), op(foo), l(len)
    {
        for (int j = 1; j < SIZE; j++)
            for (int i = 1; i + (1 << j) - 1 <= len; i++)
                // f[i][j] comes from f[i][j - 1].
                // f[i][j - 1], f[i + 2^(j - 1)] cover the range of f[i][j].
                f[i][j] = foo(f[i][j - 1], f[i + (1 << (j - 1))][j - 1]);
    };
    int query(int x, int y)
    {
        int s = LOG[y - x + 1];
        return op(f[x][s], f[y - (1 << s) + 1][s]);
    }
};
\end{minted}

\hypertarget{ux5e26ux61d2ux6807ux8bb0ux7ebfux6bb5ux6811}{%
\subsection{å¸¦æ‡’æ ‡è®°çº¿æ®µæ ‘}\label{ux5e26ux61d2ux6807ux8bb0ux7ebfux6bb5ux6811}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
const int N = 1e6;
int a[N];
int tag[4 * N];
int tree[4 * N];
int n;
void push_up(int p)
{
    tree[p] = tree[ls(p)] + tree[rs(p)];
}
void build(int p, int l, int r)
{
    if (l == r)
    {
        tree[p] = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(ls(p), l, mid);
    build(rs(p), mid + 1, r);
    push_up(p);
}
void push_down(int p, int l, int r)
{
    int mid = (l + r) >> 1;
    tag[ls(p)] += tag[p];
    tag[rs(p)] += tag[p];
    tree[ls(p)] += tag[p] * (mid - l + 1);
    tree[rs(p)] += tag[p] * (r - mid);
    tag[p] = 0;
}
void update(int nl, int nr, int k, int p = 1, int l = 1, int r = n)
{
    if (nl <= l && r <= nr)
    {
        tag[p] += k;
        tree[p] += k * (r - l + 1);
        return;
    }
    push_down(p, l, r);
    int mid = (l + r) >> 1;
    if (nl <= mid)
        update(nl, nr, k, ls(p), l, mid);
    if (nr > mid)
        update(nl, nr, k, rs(p), mid + 1, r);
    push_up(p);
}
int query(int x, int y, int l = 1, int r = n, int p = 1)
{
    int res = 0;
    if (x <= l && y >= r)
        return tree[p];
    int mid = (l + r) >> 1;
    push_down(p, l, r);
    if (x <= mid)
        res += query(x, y, l, mid, ls(p));
    if (y > mid)
        res += query(x, y, mid + 1, r, rs(p));
    return res;
}
int main()
{
    int q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    build(1, 1, n);
    while (q--)
    {
        int op, x, y, k;
        cin >> op;
        if (op == 1)
        {
            cin >> x >> y >> k;
            update(x, y, k);
        }
        else
        {
            cin >> x >> y;
            cout << query(x, y) << endl;
        }
    }
    return 0;
}
\end{minted}

\hypertarget{ux533aux95f4ux6700ux503cux7ebfux6bb5ux6811}{%
\subsection{åŒºé—´æœ€å€¼çº¿æ®µæ ‘}\label{ux533aux95f4ux6700ux503cux7ebfux6bb5ux6811}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
struct node
{
    int maxn;
} tree[800005];
int n;
int tag[800005];
void push_down(int p, int l, int r)
{ // æ ‡è®°ä¸‹å‹
    int mid = (r + l) / 2;
    tree[2 * p].maxn += tag[p];
    tree[2 * p + 1].maxn += tag[p];
    tag[2 * p] += tag[p];
    tag[2 * p + 1] += tag[p];
    tag[p] = 0;
}
void update(int l, int r, int k, int cl = 1, int cr = n, int p = 1)
{ // æ›´æ–°
    if (cl > r || cr < l)
    {
        return;
    }
    if (cl >= l && cr <= r)
    {
        tree[p].maxn += k;
        if (cl < cr)
        {
            tag[p] += k;
        }
    }
    else
    {
        int mid = (cl + cr) >> 1;
        push_down(p, cl, cr);
        if (l <= mid)
            update(l, r, k, cl, mid, 2 * p);
        if (r > mid)
            update(l, r, k, mid + 1, cr, 2 * p + 1);
        tree[p].maxn = max(tree[p << 1].maxn, tree[p * 2 + 1].maxn);
    }
}
int query(int l, int r, int cl = 1, int cr = n, int p = 1)
{ // æŸ¥è¯¢
    if (cl >= l && cr <= r)
    {
        return tree[p].maxn;
    }
    else
    {
        int mid = (cl + cr) >> 1;
        push_down(p, cl, cr);
        int tmp = 0;
        if (l <= mid)
            tmp = max(tmp, query(l, r, cl, mid, 2 * p));
        if (r > mid)
            tmp = max(tmp, query(l, r, mid + 1, cr, 2 * p + 1));
        return tmp;
    }
}
\end{minted}

\hypertarget{ux5355ux8c03ux961fux5217}{%
\subsection{å•è°ƒé˜Ÿåˆ—}\label{ux5355ux8c03ux961fux5217}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int p[N];
int head=1,tail=0;
for(int i=1;i<=n;i++){
    if(head<=tail&&p[head]==i-k){//å½“å‰0          åŒºé—´é•¿åº¦å¤§äºkæ—¶æ‰”æ‰å¤´éƒ¨
        head++;
    }
    while(head<=tail&&a[p[tail]]<=a[i]) tail--;//æ­¤æ—¶æ±‚æœ€å¤§å€¼
    p[++tail]=i;
    //åˆ™headè®°å½•åŒºé—´å†…æœ€å€¼
}
\end{minted}

\hypertarget{ux52a8ux6001ux89c4ux5212}{%
\section{3-åŠ¨æ€è§„åˆ’}\label{ux52a8ux6001ux89c4ux5212}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ux80ccux5305dp}{%
\subsection{èƒŒåŒ…DP}\label{ux80ccux5305dp}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
// å¤šé‡èƒŒåŒ…
for (int i = 1; i <= n; i++)
{
    int q = a[i].m;
    for (int j = 1; q; j *= 2)
    {
        if (j > q)
        {
            j = q;
        }
        q -= j;
        for (int k = w; k >= j * a[i].w; k--)
        {
            f[k] = max(f[k], f[k - j * a[i].w] + j * a[i].v);
        }
    }
}
\end{minted}

\hypertarget{ux4e8cux8fdbux5236ux5206ux7ec4ux4f18ux5316}{%
\subsubsection{äºŒè¿›åˆ¶åˆ†ç»„ä¼˜åŒ–}\label{ux4e8cux8fdbux5236ux5206ux7ec4ux4f18ux5316}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
index = 0;
for (int i = 1; i <= m; i++)
{
    int c = 1, p, h, k;
    cin >> p >> h >> k;
    while (k > c)
    {
        k -= c;
        list[++index].w = c * p;
        list[index].v = c * h;
        c *= 2;
    }
    list[++index].w = p * k;
    list[index].v = h * k;
}
\end{minted}

\hypertarget{ux72b6ux6001ux538bux7f29dp}{%
\subsection{çŠ¶æ€å‹ç¼©DP}\label{ux72b6ux6001ux538bux7f29dp}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int cnt[1024];
int dp[40][1024][90];
int can[2000], num = 0;
int S = 1 << n;
for (int s = 0; s < S; s++)
{
    if ((s << 1) & s)
    {
        continue;
    }
    can[++num] = s;
    for (int j = 0; j < n; j++)
    {
        if ((s >> j) & 1)
        {
            cnt[num]++;
        }
    }
    dp[1][num][cnt[num]] = 1;
}
for (int i = 2; i <= n; i++)
{
    for (int j = 1; j <= num; j++)
    {
        int x = can[j];
        for (int p = 1; p <= num; p++)
        {
            int y = can[p];
            if ((y & x) || ((y << 1) & x) || ((y >> 1) & x))
                continue;
            for (int l = 0; l <= k; l++)
            {
                dp[i][j][cnt[j] + l] += dp[i - 1][p][l];
            }
        }
    }
}
\end{minted}

æšä¸¾sçš„äºŒè¿›åˆ¶çœŸå­é›†

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
for(int j=s;j;j=(j-1)&s){
    //...
}
\end{minted}

\hypertarget{ux6570ux4f4ddp}{%
\subsection{æ•°ä½DP}\label{ux6570ux4f4ddp}}

ç°åœ¨é—®æœ‰å¤šå°‘çš„æ•°æ¯”12345å°

1.å…³äºå‰å¯¼0ï¼š00999â†’999ï¼Œ09999â†’9999

2.å…³äºlimitå‰é¢çš„æ•°æ˜¯å¦ç´§è´´ä¸Šé™

å¦‚æœå‰é¢çš„æ•°æ˜¯ç´§è´´ä¸Šé™çš„ï¼Œå½“å‰è¿™ä½æšä¸¾çš„ä¸Šé™ä¾¿æ˜¯å½“å‰æ•°çš„ä¸Šé™

å¦‚æœå‰é¢çš„æ•°ä¸æ˜¯ç´§è´´ä¸Šé™çš„ï¼Œå½“å‰è¿™ä½æšä¸¾çš„ä¸Šé™ä¾¿æ˜¯ 9

3.å…³äºDPç»´åº¦

ä¸€èˆ¬æ¥è¯´ï¼ŒDFSæœ‰å‡ ä¸ªçŠ¶æ€ï¼ŒDPå°±å‡ ä¸ªç»´åº¦ã€€ã€€

æ¯”å¦‚ç°åœ¨DPå°±æ˜¯DP {[}pos{]} {[}limt{]} {[}zero{]}

4.å…³äºè®°å¿†åŒ–DP

ç°åœ¨æšä¸¾åˆ°äº† 10Ã—Ã—Ã— å’Œ 11Ã—Ã—Ã—

æ˜¾ç„¶ è¿™ä¸¤ç§çŠ¶æ€åé¢çš„Ã—Ã—Ã—çŠ¶æ€æ•°æ˜¯ä¸€æ ·çš„

é‡ç‚¹ï¼šdp{[}pos{]}{[}limit{]}{[}zero{]}è¡¨ç¤ºå‰é¢çš„æ•°æšä¸¾çŠ¶æ€ç¡®å®šï¼Œåé¢çš„æ•°æœ‰å¤šå°‘ç§å¯èƒ½

5.å…³äºDPç»†èŠ‚

ä¸€èˆ¬æ¥è¯´æˆ‘ä»¬ä¸€å¼€å§‹éƒ½memset(dp,-1,sizeof(dp))

å¦‚æœdp{[}pos{]}{[}limt{]}{[}zero{]}!=-1 return
dp{[}pos{]}{[}limit{]}{[}zero{]};

6.å…³äºåˆå§‹åŒ–ï¼š

ä¸€å¼€å§‹ limit æ˜¯1ï¼Œè¡¨ç¤ºä¸€å¼€å§‹çš„æ•°åªèƒ½é€‰ 1\textasciitilde a{[}1{]}

ä¸€å¼€å§‹zero æ˜¯1ï¼Œå‡å®šè¡¨ç¤ºå‰é¢çš„æ•°å…¨ä¸º0

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define mp make_pair
#define pb push_back  // vectorå‡½æ•°
#define popb pop_back // vectorå‡½æ•°
#define fi first
#define se second
const int N = 20;
// const int M=;
// const int inf=0x3f3f3f3f;     //ä¸€èˆ¬ä¸ºintèµ‹æœ€å¤§å€¼,ä¸ç”¨äºmemsetä¸­
// const ll INF=0x3ffffffffffff; //ä¸€èˆ¬ä¸ºllèµ‹æœ€å¤§å€¼,ä¸ç”¨äºmemsetä¸­
int T, n, len, a[N], dp[N][2][2];
inline int read()
{
    int x = 0, f = 1;
    char ch = getchar();
    while (ch < '0' || ch > '9')
    {
        if (ch == '-')
            f = -1;
        ch = getchar();
    }
    while (ch >= '0' && ch <= '9')
    {
        x = (x << 1) + (x << 3) + (ch ^ 48);
        ch = getchar();
    }
    return x * f;
}
int dfs(int pos, bool lim, bool zero)
{
    if (pos > len)
        return 1;
    if (dp[pos][lim][zero] != -1)
        return dp[pos][lim][zero];
    int res = 0, num = lim ? a[pos] : 9;
    for (int i = 0; i <= num; i++)
        res += dfs(pos + 1, lim && i == num, zero && i == 0);
    return dp[pos][lim][zero] = res;
}
int solve(int x)
{
    len = 0;
    memset(dp, -1, sizeof(dp));
    for (; x; x /= 10)
        a[++len] = x % 10;
    reverse(a + 1, a + len + 1);
    return dfs(1, 1, 1);
}
int main()
{
    int l = read(), r = read();
    printf("%d\n", solve(r) - solve(l - 1));
    return 0;
}
\end{minted}

\hypertarget{ux72b6ux538bdpux89e3ux54c8ux5bc6ux987fux56deux8defux95eeux9898}{%
\subsection{çŠ¶å‹DPè§£å“ˆå¯†é¡¿å›è·¯é—®é¢˜}\label{ux72b6ux538bdpux89e3ux54c8ux5bc6ux987fux56deux8defux95eeux9898}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}

int dp[(1 << 21)][20];

for (int i = 0; i < (1 << (n + 1)); i++)
            for (int j = 1; j <= n; j++)
                if (dp[i][j])
                    for (int k = 1; k <= n; k++)
                        if (a[j][k] && (((i >> k) & 1) == 0))
                            dp[i | (1 << k)][k] = 1;

\end{minted}

\hypertarget{ux6570ux5b66}{%
\section{4-æ•°å­¦}\label{ux6570ux5b66}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{ux4e09ux5206-1}{%
\subsection{ä¸‰åˆ†}\label{ux4e09ux5206-1}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
//å¯»æ‰¾calå‡½æ•°çš„æå°å€¼ï¼ˆæå¤§å€¼åˆ™æŠŠ<æ”¹ä¸º>ï¼‰
while(l<r){
    ll lmid=l+(r-l)/3;
    ll rmid=r-(r-l)/3;
    if(cal(lmid)<cal(rmid)) r=rmid-1;//å°äºï¼Œé‚£ä¹ˆlå’Œrä¼šæˆä¸ºè¾ƒå¤§çš„å€¼ï¼Œå°äºç­‰äºåˆ™æ˜¯è¾ƒå°çš„å€¼
    //ä¾‹å¦‚å¯¹äºå‡½æ•°(x-40)*(x-41)ï¼Œä»æ•´æ•°èŒƒå›´çœ‹40å’Œ41éƒ½èƒ½å–å¾—æå°å€¼
    //è€Œ<æ—¶ï¼Œæœ€ål=r=41ï¼›<=æ—¶ï¼Œl=r=40
    else l=lmid+1;
}
\end{minted}

\hypertarget{ux5febux901fux5e42}{%
\subsection{å¿«é€Ÿå¹‚}\label{ux5febux901fux5e42}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int qpow(int a, int n)
{
    int ans = 1;
    while (n)
    {
        if (n & 1)
            ans = ans * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return ans;
}
\end{minted}

\hypertarget{exgcd}{%
\subsection{exgcd}\label{exgcd}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int exgcd(int a, int b, int &x, int &y)
{
    if (b == 0)
    {
        x = 1;
        y = 0;
        return a;
    }
    int d = exgcd(b, a % b, x, y), x0 = x, y0 = y;
    x = y0;
    y = x0 - (a / b) * y0;
    return d;
}
\end{minted}

\hypertarget{ux7ebfux6027inv}{%
\subsection{çº¿æ€§inv}\label{ux7ebfux6027inv}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
void getinv(int n)
{
    inv[1] = 1;
    for (int i = 2; i <= n; i++)
    {
        inv[i] = mod - ((mod / i) * inv[mod % i]) % mod;
    }
}
\end{minted}

\hypertarget{ux5206ux5757}{%
\subsection{åˆ†å—}\label{ux5206ux5757}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int ans = 0;
for (int l = 1, r; l <= n; l = r + 1)
{
    r = n / (n / l);
    ans += (r - l + 1) * (n / l);
}
cout << ans << endl;
\end{minted}

\hypertarget{ux6b27ux62c9ux7b5b}{%
\subsection{æ¬§æ‹‰ç­›}\label{ux6b27ux62c9ux7b5b}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int Eular(int n)
{
    int cnt = 0;
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= n; i++)
    {
        if (is_prime[i])
        {
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++)
        {
            is_prime[i * prime[j]] = 0;
            if (i % prime[j] == 0)
                break;
        }
    }
    return cnt;
}
\end{minted}

\hypertarget{ux6b27ux62c9ux51fdux6570}{%
\subsection{æ¬§æ‹‰å‡½æ•°}\label{ux6b27ux62c9ux51fdux6570}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int Eular(int n)
{
    int cnt = 0;
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= n; i++)
    {
        if (is_prime[i])
        {
            prime[++cnt] = i;
        }
        for (int j = 1; j <= cnt && i * prime[j] <= n; j++)
        {
            is_prime[i * prime[j]] = 0;
            if (i % prime[j] == 0)
                break;
        }
    }
    return cnt;
}
\end{minted}

\hypertarget{ux7ec4ux5408ux6570}{%
\subsection{ç»„åˆæ•°}\label{ux7ec4ux5408ux6570}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int fac[N];
int inv[N];
void init(int n)
{
    fac[0] = 1;
    inv[0] = 1;
    inv[1] = 1;
    fac[1] = 1;
    for (int i = 2; i <= 2 * n; i++)
    {
        fac[i] = fac[i - 1] * i % mod;
        inv[i] = (mod - mod / i) * inv[mod % i] % mod;
    }
    for (int i = 1; i <= n; i++)
    {
        inv[i] = inv[i] * inv[i - 1] % mod;
    }
}
int C(int n, int m)
{
    if (m > n || m < 0 || n < 0)
        return 0;
    return fac[n] * inv[m] % mod * inv[n - m] % mod;
}
\end{minted}

\hypertarget{ux6269ux5c55ux6b27ux62c9ux5b9aux7406}{%
\subsection{æ‰©å±•æ¬§æ‹‰å®šç†}\label{ux6269ux5c55ux6b27ux62c9ux5b9aux7406}}

\hypertarget{ux5b9aux4e49}{%
\subsubsection{å®šä¹‰}\label{ux5b9aux4e49}}

\[
a^b \equiv \begin{cases}
  a^{b \bmod \varphi(m)},                &\gcd(a,m) =  1,                   \\
  a^b,                                   &\gcd(a,m)\ne 1, b <   \varphi(m), \\
  a^{(b \bmod \varphi(m)) + \varphi(m)}, &\gcd(a,m)\ne 1, b \ge \varphi(m).
\end{cases} \pmod m
\]

\hypertarget{ux89e3ux91ca}{%
\subsubsection{è§£é‡Š}\label{ux89e3ux91ca}}

è¯»è€…å¯èƒ½å¯¹ç¬¬äºŒè¡Œäº§ç”Ÿç–‘é—®ï¼Œè¿™ä¸€è¡Œè¡¨è¾¾çš„æ„æ€æ˜¯ï¼šå¦‚æœ \(b < \varphi(m)\)
çš„è¯ï¼Œå°±ä¸èƒ½é™å¹‚äº†ã€‚

ä¸»è¦æ˜¯å› ä¸ºé¢˜ç›®ä¸­ \(m\) ä¸ä¼šå¤ªå¤§ï¼Œè€Œå¦‚æœ
\(b < \varphi(m)\)ï¼Œè‡ªç„¶å¤æ‚åº¦æ˜¯å¯ä»¥æ¥å—çš„ã€‚è€Œå¦‚æœ \(b \ge \varphi(m)\)
çš„è¯ï¼Œå¤æ‚åº¦å¯èƒ½å°±è¶…å‡ºé¢„æœŸäº†ï¼Œè¿™ä¸ªæ—¶å€™æˆ‘ä»¬æ‰éœ€è¦é™å¹‚æ¥é™ä½å¤æ‚åº¦ã€‚

\hypertarget{ux5361ux7279ux5170ux6570}{%
\subsection{å¡ç‰¹å…°æ•°}\label{ux5361ux7279ux5170ux6570}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
int C(int n, int m)
{
    return fac[n] * qpow(fac[n - m], mod - 2) % mod * qpow(fac[m], mod - 2) % mod;
}
int cat(int n)
{
    return C(2 * n, n) * qpow(n + 1, mod - 2) % mod;
}
\end{minted}

\hypertarget{ux77e9ux9635}{%
\subsection{çŸ©é˜µ}\label{ux77e9ux9635}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
class matrix
{
public:
    int x[105][105];
    int sz;
    matrix(int n)
    {
        sz = n;
        for (int i = 1; i <= sz; i++)
        {
            for (int j = 1; j <= sz; j++)
            {
                x[i][j] = 0;
            }
        }
    }
    matrix mul(matrix a, matrix b);
    matrix qpow(matrix a, int n);
    void tra(matrix a);
};

matrix matrix::mul(matrix a, matrix b)
{
    matrix c(a.sz);
    for (int i = 1; i <= a.sz; i++)
        for (int j = 1; j <= a.sz; j++)
            for (int k = 1; k <= a.sz; k++)
                c.x[i][j] = (c.x[i][j] % mod + (a.x[i][k] * b.x[k][j]) % mod) % mod;
    return c;
}
matrix matrix::qpow(matrix a, int n)
{
    matrix res(a.sz);
    for (int i = 1; i <= a.sz; i++)
        res.x[i][i] = 1;
    while (n > 0)
    {
        if (n & 1)
            res = mul(res, a);
        a = mul(a, a);
        n >>= 1;
    }
    return res;
}
void matrix::tra(matrix a)
{
    for (int i = 1; i <= a.sz; i++)
    {
        for (int j = 1; j <= a.sz; j++)
        {
            cout << a.x[i][j] << " ";
        }
        cout << endl;
    }
}
\end{minted}

\hypertarget{ux9ad8ux65afux6d88ux5143}{%
\subsection{é«˜æ–¯æ¶ˆå…ƒ}\label{ux9ad8ux65afux6d88ux5143}}

æ±‚è§£çº¿æ€§æ–¹ç¨‹ç»„

å°†å„ç³»æ•°åˆä¸ºçŸ©é˜µï¼Œå†å°†å…¶å˜ä¸ºä¸Šä¸‰è§’çŸ©é˜µ

è¿‡ç¨‹ä¸­é€šå¸¸è¦ä¿è¯é€‰æ‹©çš„ä¸»å…ƒç»å¯¹å€¼æœ€å¤§ä»¥ä¿è¯ç²¾åº¦

n\^{}3

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
const int N = 100;
const double eps = 1e-10;
int n;
double a[N + 1][N + 1], b[N + 1];

void gauss()
{
    int l = 1;
    for (int i = 1; i <= n; i++)
    { // nåˆ—
        for (int j = l; j <= n; j++)
        { // æ‰¾ä¸‹é¢æ‰€æœ‰è¡Œä¸­è¿™ä¸€åˆ—å¤„ç»å¯¹å€¼æœ€å¤§çš„
            if (abs(a[j][i]) > abs(a[l][i]))
            {
                for (int k = i; k <= n; k++)
                {
                    swap(a[l][k], a[j][k]);
                }
                swap(b[l], b[j]);
            }
        }
        if (abs(a[l][i]) < eps)
            continue;
        for (int j = 1; j <= n; j++)
        { // å¯¹æ‰€æœ‰å…¶ä»–è¡Œï¼Œæ›´æ–°å€¼
            if (j != l && abs(a[j][i]) > eps)
            {
                double delta = a[j][i] / a[l][i];
                for (int k = i; k <= n; k++)
                {
                    a[j][k] -= a[l][k] * delta;
                }
                b[j] -= b[l] * delta;
            }
        }
        ++l;
    }

    for (int i = l; i <= n; i++)
    { // å‡å¦‚æœ‰å‰©ä¸‹çš„è¡Œä¸”bå€¼ä¸ä¸º0åˆ™æ— è§£
        if (abs(b[i]) > eps)
        {
            cout << "æ— è§£" << endl;
            return;
        }
    }
    if (l <= n)
    {
        cout << "æ— ç©·å¤šè§£" << endl;
    }
    else
    {
        for (int i = 1; i <= n; i++)
        {
            cout << fixed << setprecision(10) << b[i] / a[i][i] << endl;
        }
    }
}
\end{minted}

\hypertarget{ux7b2cux4e8cux7c7bux65afux7279ux6797ux6570stirling-number}{%
\subsection{ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°ï¼ˆStirling
Numberï¼‰}\label{ux7b2cux4e8cux7c7bux65afux7279ux6797ux6570stirling-number}}

\textbf{ç¬¬äºŒç±»æ–¯ç‰¹æ—æ•°}ï¼ˆæ–¯ç‰¹æ—å­é›†æ•°ï¼‰\(\begin{Bmatrix}n\\ k\end{Bmatrix}\)ï¼Œä¹Ÿå¯è®°åš
\(S(n,k)\)ï¼Œè¡¨ç¤ºå°† \(n\) ä¸ªä¸¤ä¸¤ä¸åŒçš„å…ƒç´ ï¼Œåˆ’åˆ†ä¸º \(kâ€‹\)
ä¸ªäº’ä¸åŒºåˆ†çš„éç©ºå­é›†çš„æ–¹æ¡ˆæ•°ã€‚

\hypertarget{ux9012ux63a8ux5f0f}{%
\subsubsection{é€’æ¨å¼}\label{ux9012ux63a8ux5f0f}}

\[
\begin{Bmatrix}n\\ k\end{Bmatrix}=\begin{Bmatrix}n-1\\ k-1\end{Bmatrix}+k\begin{Bmatrix}n-1\\ k\end{Bmatrix}
\]

\hypertarget{ux901aux9879ux516cux5f0f}{%
\subsubsection{é€šé¡¹å…¬å¼}\label{ux901aux9879ux516cux5f0f}}

\[
\begin{Bmatrix}n\\m\end{Bmatrix}=\sum\limits_{i=0}^m\dfrac{(-1)^{m-i}i^n}{i!(m-i)!}
\]

\hypertarget{ux56feux8bba}{%
\section{5-å›¾è®º}\label{ux56feux8bba}}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{dijkstra}{%
\subsection{dijkstra}\label{dijkstra}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
using namespace std;
#define ll long long
const ll maxn = 10+1e5;
const ll inf = 0x3f3f3f3f;
typedef pair<ll,ll> pll;
    vector<pll> mp[100100];
    ll n,m,s;
    ll dis[100100];
    ll vis[100100];

void dij(ll s){
    for(ll i=1;i<=n;i++){
        dis[i]=inf;
    }
    dis[s]=0;
    priority_queue<pll,vector<pll>,greater<pll> > q;
    q.push({dis[s],s});
    while(!q.empty()){
        ll u=q.top().second;
        q.pop();
        if(vis[u]) continue;
        vis[u]=1;
        for(auto [w,v]:mp[u]){
            if(dis[u]+w<dis[v]){
                dis[v]=dis[u]+w;
                q.push({dis[v],v});
            }
        }
    }
}
int main() {
    cin>>n>>m>>s;
    for(ll i=1;i<=m;i++){
        ll u,v,w;
        cin>>u>>v>>w;
        mp[u].push_back({w,v});
    }
    dij(s);
    for(ll i=1;i<=n;i++)
        cout<<dis[i]<<" ";
    return 0;
}
\end{minted}

\hypertarget{ux5e76ux67e5ux96c6-1}{%
\subsection{å¹¶æŸ¥é›†}\label{ux5e76ux67e5ux96c6-1}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
    ll fa[maxn];
void init(ll n){
    for(ll i=1;i<=n;i++){
        fa[i]=i;
    }
}
ll find(ll x){
    if(fa[x]==x)
        return x;
    fa[x]=find(fa[x]);
    return fa[x];
}
void merge(ll x,ll y){
    if(find(x)==find(y)) return ;
    fa[find(x)]=find(y);
}
\end{minted}

\hypertarget{ux6700ux5c0fux751fux6210ux6811}{%
\subsection{æœ€å°ç”Ÿæˆæ ‘}\label{ux6700ux5c0fux751fux6210ux6811}}

\hypertarget{prim-on2}{%
\subsubsection{prim O(n\^{}2)}\label{prim-on2}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
    vector<pll> edge[maxn];
    ll dis[maxn];
    ll vis[maxn];
void update(ll u){
    for(auto [v,w]:edge[u]){
        dis[v]=min(dis[v],w);
    }

}
ll prim(ll n){
    for(ll i=1;i<=n;i++){
        vis[i]=0;
        dis[i]=inf;
    }
    vis[1]=1;
    update(1);
    ll ans=0;
    for(ll i=1;i<=n-1;i++){//è¿æ¥n-1æ¡è¾¹
        ll pos,mi=inf;
        for(ll j=1;j<=n;j++){
            if(vis[j]) continue;
            if(dis[j]<mi){
                mi=dis[j];
                pos=j;
            }
        }
        ans+=mi;
        vis[pos]=1;
        update(pos);    
    }
    return ans;
}
\end{minted}

\hypertarget{prim-omlogm-ux5c0fux6839ux5806ux4f18ux5316}{%
\subsubsection{prim O(mlogm)
(å°æ ¹å †ä¼˜åŒ–)}\label{prim-omlogm-ux5c0fux6839ux5806ux4f18ux5316}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
    vector<pll> edge[maxn];
    ll dis[maxn];
    ll vis[maxn];
ll prim(ll n){
    for(ll i=1;i<=n;i++){
        vis[i]=0;
        dis[i]=inf;
    }
    ll ans=0;
    priority_queue<pll,vector<pll>,greater<pll>> pq;
    pq.push({0,1});
    while(!pq.empty()){
        auto [d,u]=pq.top();
        pq.pop();
        if(vis[u]) continue;
        vis[u]=1;
        ans+=d;
        for(auto [v,w]:edge[u]){
            if(!vis[v]&&w<dis[v]){
                dis[v]=w;
                pq.push({dis[v],v});
            }
        }
    }
    return ans;
}
\end{minted}

\hypertarget{kruskal}{%
\subsubsection{kruskal}\label{kruskal}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
typedef struct{
    ll u,v,w;
}eg;
    eg e[maxm];
    vector<pll> edge[maxn];
    ll fa[maxn];
bool cmp(eg a,eg b){
    return a.w<b.w;
}
ll find(ll a){
    return (fa[a]==a)?a:(fa[a]=find(fa[a]));
}
void merge(ll a,ll b){
    fa[a]=b;
}
ll kruscal(ll n,ll m){
    for(ll i=1;i<=n;i++){
        fa[i]=i;
    }
    sort(e+1,e+m+1,cmp);
    ll ans=0;
    for(ll i=1;i<=m;i++){
        ll a=find(e[i].u);
        ll b=find(e[i].v);
        if(a!=b){
            merge(a,b);
            ans+=e[i].w;
            n--;
        }
    }
    if(n==1){
        return ans;
    }else{
        return inf;
    }
}
for(ll i=1;i<=m;i++){
    ll u,v,w;
    cin>>u>>v>>w;
    edge[u].push_back({v,w});
    edge[v].push_back({u,w});
    e[i].u=u;e[i].v=v;e[i].w=w;
}
\end{minted}

\hypertarget{lca}{%
\subsection{LCA}\label{lca}}

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
using namespace std;
#define IOS ios::sync_with_stdio(false),cin.tie(nullptr), cout.tie(nullptr);
#define ll long long
#define ull unint long long
#define lowbit(i) ((i) & (-i))
#define ls(p) (p << 1)
#define rs(p) (p << 1 | 1)
#define rep(i, a, b) for (ll i = a; i <= b; i++)
#define per(i, a, b) for (ll i = a; i >= b; i--)

typedef pair<ll, ll> pll;
const ll mod = 1e9 + 7;
const ll inf = 0x3f3f3f3f;
const ll maxn = 5e5 + 200;

    ll n, q, root; 
    vector<ll> mp[N];
    ll lg2[maxn];
    ll dep[maxn];
    ll f[maxn][20];
    ll vis[maxn];
void dfs(ll u, ll fa = 0){
    if (vis[u]) return;
    vis[u] = 1;
    dep[u] = dep[fa] + 1;
    f[u][0] = fa;
    for (ll i = 1; i <= lg2[dep[u]]; i++){
        f[u][i] = f[f[u][i - 1]][i - 1];
    }
    for (auto v : mp[u]){
        dfs(v, u);
    }
}
ll lca(ll a, ll b){
    if (dep[a] > dep[b])
        swap(a, b);
    while (dep[a] != dep[b])
        b = f[b][lg2[dep[b] - dep[a]]];
    if (a == b)
        return a;
    for (ll k = lg2[dep[a]]; k >= 0; k--){
        if (f[a][k] != f[b][k]){
            a = f[a][k], b = f[b][k];
        }
    }
    return f[a][0];
}
int main(){
    IOS 
    cin >> n >> q >> root;
    for (ll i = 1; i < n; i++){
        ll u, v;
        cin >> u >> v;
        mp[u].push_back(v);
        mp[v].push_back(u);
    }
    for (ll i = 2; i <= n; i++){
        lg2[i] = lg2[i / 2] + 1;
    }
    dfs(root);
    while (q--){
        ll u, v;
        cin >> u >> v;
        cout << lca(u, v) << endl;
    }
    return 0;
}
\end{minted}

\hypertarget{ux6709ux5411ux56feux5f3aux8054ux901aux5206ux91cf}{%
\subsection{æœ‰å‘å›¾å¼ºè”é€šåˆ†é‡}\label{ux6709ux5411ux56feux5f3aux8054ux901aux5206ux91cf}}

æœ‰å‘éå¼ºè¿é€šå›¾ä¸­çš„\textbf{æå¤§}å¼ºè¿é€šå­å›¾æˆ‘ä»¬ç§°ä¸º\textbf{å¼ºè¿é€šåˆ†é‡}

å¦‚æœä¸€ä¸ªæœ‰å‘å›¾ä¸æ˜¯å¼ºè¿é€šå›¾ä½†æ˜¯å°†\textbf{æ‰€æœ‰æœ‰å‘è¾¹æ¢æˆæ— å‘è¾¹}å˜æˆäº†å¼ºè¿é€šå›¾ï¼Œé‚£ä¹ˆè¯¥å›¾å°±æ˜¯\textbf{å¼±è¿é€šå›¾}ã€‚

Kosarajuç®—æ³•

é¦–å…ˆå¯¹åŸå›¾ ğº è¿›è¡Œéå†ï¼Œè®°å½•èŠ‚ç‚¹è®¿é—®\textbf{å®Œ}çš„é¡ºåº ğ‘‘ğ‘– ï¼Œ ğ‘‘ğ‘– è¡¨ç¤ºç¬¬ ğ‘–
ä¸ªè®¿é—®å®Œçš„èŠ‚ç‚¹ç¼–å·ã€‚

æˆ‘ä»¬é€‰æ‹©æœ€æ™š\textbf{è®¿é—®å®Œ}çš„èŠ‚ç‚¹ï¼Œå¯¹ ğº
çš„åå‘å›¾è¿›è¡Œéå†ï¼Œå®ƒèƒ½å¤Ÿéå†åˆ°çš„é¡¶ç‚¹å’Œå®ƒç»„æˆäº†ä¸€ä¸ª
SCCï¼ŒæŠŠè¯¥è¿‡ç¨‹æ‰€éå†åˆ°çš„èŠ‚ç‚¹æ‰“æ ‡è®°ï¼Œæ¥ä¸‹æ¥ç»§ç»­æ‰¾æœ€æ™š\textbf{è®¿é—®å®Œ}ä¸”æœªè¢«æ‰“ä¸Šæ ‡è®°çš„èŠ‚ç‚¹è¿›è¡Œéå†æ“ä½œã€‚

\begin{verbatim}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=1e5+7;
int n,m;
vector<int>e[Maxn],e1[Maxn];
// e å­˜æ­£å‘è¾¹,e1 å­˜åå‘è¾¹ 
bool vis[Maxn];
int d[Maxn],cnt,col[Maxn],cnt1;
void dfs1(int u){
    vis[u]=1;
    for(auto v:e[u]) if(!vis[v]) dfs1(v);
    d[++cnt]=u;
}
vector<int>ans[Maxn];
void dfs2(int u){
    col[u]=cnt1;
    ans[cnt1].push_back(u);
    for(auto v:e1[u]) if(!col[v]) dfs2(v);
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        e[u].push_back(v);
        e1[v].push_back(u);
    }
    for(int i=1;i<=n;i++) if(!vis[i]) dfs1(i);
    for(int i=n;i;i--) if(!col[d[i]]) ++cnt1,dfs2(d[i]);
    for(int i=1;i<=cnt1;i++) sort(ans[i].begin(),ans[i].end());
    printf("%d\n",cnt1);
    for(int i=1;i<=n;i++){
        if(ans[col[i]].size()){
            for(auto j:ans[col[i]]) printf("%d ",j);
            puts("");
            ans[col[i]].resize(0);
        }
    }
    return 0;
}
\end{verbatim}

Tarjanç®—æ³•

åœ¨ DFS è¿‡ç¨‹ä¸­ï¼Œæˆ‘ä»¬ä¼šé‡åˆ°å¦‚ä¸‹ 4 ç§è¾¹ï¼š

\begin{itemize}
\item
  æ ‘æè¾¹ï¼šDFS è¿‡ç¨‹ä¸­ç»è¿‡çš„è¾¹ï¼Œå³ DFS æœç´¢æ ‘ä¸Šçš„è¾¹ã€‚
\item
  å‰å‘è¾¹ï¼šä»ç¥–å…ˆèŠ‚ç‚¹æŒ‡å‘åä»£èŠ‚ç‚¹çš„éæ ‘æè¾¹ï¼Œæˆ‘ä»¬ç§°ä¸ºå‰å‘è¾¹ã€‚
\item
  è¿”ç¥–è¾¹ï¼ˆåå‘è¾¹ï¼‰ï¼šä»åä»£èŠ‚ç‚¹æŒ‡å‘ç¥–å…ˆèŠ‚ç‚¹çš„éæ ‘æè¾¹ï¼Œæˆ‘ä»¬ç§°ä¸ºè¿”ç¥–è¾¹ï¼ˆåå‘è¾¹ï¼‰ã€‚
\item
  æ¨ªå‰è¾¹ï¼šä¸¤ç«¯æ— ç¥–å…ˆå…³ç³»çš„éæ ‘æè¾¹ï¼Œæˆ‘ä»¬ç§°ä¸ºæ¨ªå‰è¾¹ã€‚

  æ¯ä¸ªå¼ºè¿é€šåˆ†é‡éƒ½æ˜¯ DFS æ ‘çš„ä¸€é¢—å­æ ‘ï¼Œæœç´¢æ—¶ï¼ŒæŠŠå½“å‰ DFS
  æ ‘ç§æœªå¤„ç†çš„èŠ‚ç‚¹åŠ å…¥ä¸€ä¸ªæ ˆï¼Œå›æº¯æ—¶å¯ä»¥åˆ¤æ–­æ ˆé¡¶åˆ°æ ˆä¸­çš„èŠ‚ç‚¹æ˜¯å¦æ„æˆä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ã€‚
\end{itemize}

æˆ‘ä»¬ä¸å¦¨å®šä¹‰ ğ‘‘ğ‘“ğ‘›(ğ‘¢) è¡¨ç¤ºèŠ‚ç‚¹ ğ‘¢ åœ¨ DFS ä¸­çš„éå†ç¼–å·ï¼ˆ\textbf{æ—¶é—´æˆ³}ï¼‰ï¼Œ
ğ‘™ğ‘œğ‘¤(ğ‘¢) è¡¨ç¤º ğ‘¢ æˆ– ğ‘¢
çš„å­æ ‘èƒ½å¤Ÿæœ€å¤šåªé€šè¿‡\textbf{ä¸€æ¡éæ ‘æè¾¹ï¼ˆä¸åŒ…å«æ ‘è¾¹ï¼‰}å›æº¯çš„æœ€æ—©çš„ ğ‘‘ğ‘“ğ‘›
å€¼ï¼Œç”¨ä¸€ä¸ªæ ˆè®°å½•ç»è¿‡çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼š

\begin{itemize}
\tightlist
\item
  åˆå§‹æƒ…å†µæœ‰ ğ‘™ğ‘œğ‘¤(ğ‘¢)=ğ‘‘ğ‘“ğ‘›(ğ‘¢) ã€‚
\item
  å¯¹äºè¾¹ (ğ‘¢,ğ‘£) ï¼Œå¦‚æœ ğ‘¢ ä¸º ğ‘£ çš„çˆ¶äº²èŠ‚ç‚¹ï¼Œåˆ™æœ‰
  ğ‘™ğ‘œğ‘¤(ğ‘¢)=min\{ğ‘™ğ‘œğ‘¤(ğ‘¢),ğ‘™ğ‘œğ‘¤(ğ‘£)\} ã€‚
\item
  å¯¹äºè¾¹ (ğ‘¢,ğ‘£) ä¸ºè¿”ç¥–è¾¹æˆ–è€…æŒ‡å‘éå…¶ä»–å¼ºè¿é€šçš„æ¨ªå‰è¾¹ï¼Œåˆ™æœ‰
  ğ‘™ğ‘œğ‘¤(ğ‘¢)=min\{ğ‘™ğ‘œğ‘¤(ğ‘¢),ğ‘‘ğ‘“ğ‘›(ğ‘£)\} ã€‚
\end{itemize}

åœ¨èŠ‚ç‚¹ ğ‘¢ æœç´¢å®Œæ¯•ä¹‹åï¼Œå¦‚æœ ğ‘™ğ‘œğ‘¤(ğ‘¢)=ğ‘‘ğ‘“ğ‘›(ğ‘¢) ï¼Œé‚£ä¹ˆè¯´æ˜ä»¥ ğ‘¢
ä¸º\textbf{æ ¹èŠ‚ç‚¹}çš„æœç´¢å­æ ‘ä¸ŠåŠæ ˆä¸­åœ¨ ğ‘¢
å†…çš„å…ƒç´ ç»„æˆäº†ä¸€ä¸ªå¼ºè¿é€šåˆ†é‡ï¼Œç„¶ååˆ é™¤æ ˆå†…çš„è¿™äº›å…ƒç´ ï¼Œä¸æ–­é‡å¤è¯¥æ“ä½œç›´åˆ°æ‰¾åˆ°æ‰€æœ‰çš„å¼ºè¿é€šåˆ†é‡ã€‚

ä¾‹ \href{https://www.luogu.com.cn/problem/P3387}{P3387 ã€æ¨¡æ¿ã€‘ç¼©ç‚¹ -
æ´›è°· \textbar{} è®¡ç®—æœºç§‘å­¦æ•™è‚²æ–°ç”Ÿæ€ (luogu.com.cn)}

\begin{verbatim}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int Maxn=1e5+7;
int n,m;
vector<int>e[Maxn];
int col[Maxn],dfn[Maxn],low[Maxn],cnt;
int stk[Maxn],top,_cnt;
vector<int>ans[Maxn];
void Tarjan(int u){
    dfn[u]=low[u]=++cnt;
    stk[++top]=u;
    for(auto v:e[u]){
        if(!dfn[v]) Tarjan(v),low[u]=min(low[u],low[v]);
        else if(!col[v]) low[u]=min(low[u],dfn[v]);
    }
    if(low[u]==dfn[u]){
        col[u]=++_cnt;
        ans[_cnt].push_back(u);
        while(stk[top]!=u)  
            ans[_cnt].push_back(stk[top]),col[stk[top--]]=_cnt;
        --top;
    }
}
int main(){
    scanf("%d%d",&n,&m);
    for(int i=1,u,v;i<=m;i++){
        scanf("%d%d",&u,&v);
        e[u].push_back(v);
    }
    for(int i=1;i<=n;i++) if(!dfn[i]) Tarjan(i);
    for(int i=1;i<=_cnt;i++) sort(ans[i].begin(),ans[i].end());
    printf("%d\n",_cnt);
    for(int i=1;i<=n;i++){
        if(ans[col[i]].size()){
            for(auto j:ans[col[i]]) printf("%d ",j);
            puts("");
            ans[col[i]].resize(0);
        }
    }
    return 0;
}
\end{verbatim}

\hypertarget{ux5272ux70b9ux5272ux8fb9}{%
\subsection{å‰²ç‚¹å‰²è¾¹}\label{ux5272ux70b9ux5272ux8fb9}}

\begin{itemize}
\tightlist
\item
  å‰²ç‚¹ï¼šåœ¨\textbf{æ— å‘å›¾}ä¸­ï¼Œåˆ å»è¯¥ç‚¹åä½¿å¾—è¿é€šå—æ•°å¢åŠ çš„ç»“ç‚¹ç§°ä¸º
  \textbf{å‰²ç‚¹}ã€‚
\item
  å‰²è¾¹ï¼ˆæ¡¥ï¼‰ï¼šåœ¨\textbf{æ— å‘å›¾}ä¸­ï¼Œåˆ å»è¯¥è¾¹åä½¿å¾—è¿é€šå—æ•°å¢åŠ çš„è¾¹ç§°ä¸º
  \textbf{å‰²è¾¹ï¼ˆæ¡¥ï¼‰}ã€‚
\end{itemize}

ä¸€ä¸ªå›¾å¯èƒ½ä¼šæœ‰å¤šä¸ªå‰²ç‚¹æˆ–è€…å‰²è¾¹ï¼Œä½†æ˜¯æœ‰å‰²ç‚¹çš„å›¾ä¸ä¸€å®šå­˜åœ¨å‰²è¾¹ï¼Œæœ‰å‰²è¾¹çš„å›¾ä¸ä¸€å®šå­˜åœ¨å‰²ç‚¹ã€‚

\hypertarget{ux5272ux70b9}{%
\paragraph{å‰²ç‚¹}\label{ux5272ux70b9}}

å’Œæœ‰å‘å›¾æ±‚ SCC ä¸€æ ·ï¼Œæˆ‘ä»¬ä¼šåœ¨æœç´¢è¿‡ç¨‹ä¸­é‡åˆ°ä¸¤ç§æœç´¢æ ‘ä¸Šçš„è¾¹ï¼š

\begin{itemize}
\tightlist
\item
  æ ‘æè¾¹ï¼šDFS è¿‡ç¨‹ä¸­ç»è¿‡çš„è¾¹ï¼Œå³ DFS æœç´¢æ ‘ä¸Šçš„è¾¹ã€‚
\item
  è¿”ç¥–è¾¹ï¼ˆåå‘è¾¹ï¼‰ï¼šä»åä»£èŠ‚ç‚¹æŒ‡å‘ç¥–å…ˆèŠ‚ç‚¹çš„éæ ‘æè¾¹ï¼Œæˆ‘ä»¬ç§°ä¸ºè¿”ç¥–è¾¹ï¼ˆåå‘è¾¹ï¼‰ã€‚
\end{itemize}

ä¸åŒ…å«æ¨ªå‰è¾¹å’Œå‰å‘è¾¹ï¼Œå› ä¸ºè¿™æ˜¯\textbf{æ— å‘å›¾}ã€‚

æˆ‘ä»¬ä¸å¦¨å®šä¹‰ ğ‘‘ğ‘“ğ‘›(ğ‘¢) è¡¨ç¤ºèŠ‚ç‚¹ ğ‘¢ åœ¨ DFS ä¸­çš„éå†ç¼–å·ï¼ˆ\textbf{æ—¶é—´æˆ³}ï¼‰ï¼Œ
ğ‘™ğ‘œğ‘¤(ğ‘¢) è¡¨ç¤º ğ‘¢ æˆ– ğ‘¢
çš„å­æ ‘èƒ½å¤Ÿæœ€å¤šåªé€šè¿‡\textbf{ä¸€æ¡éæ ‘æè¾¹ï¼ˆä¸åŒ…å«æ ‘è¾¹ï¼‰}å›æº¯çš„æœ€æ—©çš„ ğ‘‘ğ‘“ğ‘›
å€¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬å¯ä»¥å¾—å‡ºï¼š

\begin{itemize}
\tightlist
\item
  åˆå§‹æƒ…å†µæœ‰ ğ‘™ğ‘œğ‘¤(ğ‘¢)=ğ‘‘ğ‘“ğ‘›(ğ‘¢) ã€‚
\item
  å¯¹äºè¾¹ (ğ‘¢,ğ‘£) ï¼Œå¦‚æœ ğ‘£ æ²¡æœ‰è¢«æœç´¢åˆ°ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å°±æ˜¯æ ‘æè¾¹ï¼Œåˆ™æœ‰
  ğ‘™ğ‘œğ‘¤(ğ‘¢)=min\{ğ‘™ğ‘œğ‘¤(ğ‘¢),ğ‘™ğ‘œğ‘¤(ğ‘£)\} ã€‚
\item
  å¯¹äºè¾¹ (ğ‘¢,ğ‘£) ï¼Œå¦‚æœ ğ‘£ è¢«æœç´¢åˆ°äº†ï¼Œé‚£ä¹ˆè¿™æ¡è¾¹å°±æ˜¯è¿”ç¥–è¾¹ï¼Œåˆ™æœ‰
  ğ‘™ğ‘œğ‘¤(ğ‘¢)=min\{ğ‘™ğ‘œğ‘¤(ğ‘¢),ğ‘‘ğ‘“ğ‘›(ğ‘£)\} ã€‚
\end{itemize}

å¯¹äºä¸€ä¸ªèŠ‚ç‚¹ ğ‘¢ ï¼Œå®ƒçš„å­èŠ‚ç‚¹ ğ‘£ ï¼Œè‹¥ ğ‘™ğ‘œğ‘¤(ğ‘£)â‰¥ğ‘‘ğ‘“ğ‘›(ğ‘¢) ï¼Œè¯´æ˜ ğ‘£
æ— æ³•é€šè¿‡å®ƒå­æ ‘çš„èŠ‚ç‚¹åˆ°è¾¾ ğ‘‘ğ‘“ğ‘› æ›´å°çš„èŠ‚ç‚¹ï¼Œä¹Ÿå°±æ˜¯ ğ‘£ æ— æ³•ä¸ç»è¿‡ç‚¹ ğ‘¢ åˆ°è¾¾æ¯”
ğ‘¢ çš„ ğ‘‘ğ‘“ğ‘› å€¼æ›´å°çš„èŠ‚ç‚¹ï¼Œæ˜¾ç„¶ ğ‘¢ æ˜¯ä¸€ä¸ªå‰²ç‚¹ï¼Œåä¹‹ ğ‘¢ å°±ä¸æ˜¯ä¸€ä¸ªå‰²ç‚¹ã€‚

ä½†æ˜¯å¯¹äºæ ¹èŠ‚ç‚¹ ğ‘¢ ï¼Œå®ƒçš„ ğ‘‘ğ‘“ğ‘›
å€¼ä¸€å®šæ˜¯æ•´ä¸ªåºåˆ—çš„æœ€å°å€¼ï¼Œå› æ­¤ä¸Šè¿°æ–¹æ³•ä¸ç®¡ç”¨ï¼Œå¦‚æœå®ƒå­˜åœ¨ä¸¤ä¸ªåŠä»¥ä¸Šçš„å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæŠŠ
ğ‘¢ åˆ é™¤åç»å¯¹ä¼šæŠŠ ğ‘¢ å­èŠ‚ç‚¹çš„å­æ ‘åˆ†å‰²å¼€æ¥ï¼Œæ­¤æ—¶ ğ‘¢ æ˜¯å‰²ç‚¹ã€‚

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=1e5+7;
struct edge1{
    ll v,Next;
}Edge[Maxn<<1];
ll n,m,tot,low[Maxn],dfn[Maxn],cnt,root,ans,head[Maxn];
bool flg[Maxn];
inline void add(ll u,ll v){
    Edge[++tot]=(edge1){v,head[u]},head[u]=tot;
}
void tarjan(ll u){
    dfn[u]=low[u]=++cnt;
    ll ch=0;
    for(ll i=head[u];i;i=Edge[i].Next){
        ll v=Edge[i].v;
        if(!dfn[v]){
            ch++;
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>=dfn[u]&&u!=root) flg[u]=1;
            
        }
        else low[u]=min(low[u],dfn[v]);
    }
    if(ch>=2&&root==u) flg[u]=1;
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1,u,v;i<=m;i++) 
        scanf("%lld%lld",&u,&v),add(u,v),add(v,u); 
    for(ll i=1;i<=n;i++)
        if(!dfn[i])
            root=i,tarjan(i);
    for(ll i=1;i<=n;i++)
        if(flg[i])
            ++ans;
    printf("%lld\n",ans);
    for(ll i=1;i<=n;i++)
        if(flg[i])
            printf("%lld ",i);
    return 0;
}
\end{minted}

\hypertarget{ux5272ux8fb9}{%
\paragraph{å‰²è¾¹}\label{ux5272ux8fb9}}

å‰²è¾¹çš„æ±‚æ³•å’Œå‰²ç‚¹çš„æ±‚æ³•ç±»ä¼¼ï¼Œæˆ‘ä»¬ç»§ç»­ä½¿ç”¨ç›¸åŒå®šä¹‰çš„ ğ‘™ğ‘œğ‘¤ å’Œ ğ‘‘ğ‘“ğ‘› ã€‚

å¾ˆæ˜¾ç„¶ï¼Œæ ‘æè¾¹ä½¿å¾—æ•´ä¸ªå›¾è¿é€šï¼Œè€Œéæ ‘è¾¹åˆ é™¤åå¹¶ä¸å½±å“å›¾çš„è¿é€šæ€§ï¼Œå› æ­¤\textbf{å‰²è¾¹ä¸€å®šæ˜¯æ ‘æè¾¹}ã€‚

å‡è®¾å½“å‰èŠ‚ç‚¹ä¸º ğ‘¢ ï¼Œå®ƒæœ‰å­èŠ‚ç‚¹ ğ‘£ ï¼Œé‚£ä¹ˆè¾¹ (ğ‘¢,ğ‘£) ä¸ºå‰²è¾¹æ—¶å½“ä¸”ä»…å½“
ğ‘™ğ‘œğ‘¤(ğ‘£)\textgreater ğ‘‘ğ‘“ğ‘›(ğ‘¢) ï¼Œåªè¦ ğ‘£ çš„èŠ‚ç‚¹èƒ½é€šè¿‡éæ ‘è¾¹æ¥åˆ°æ¯” ğ‘¢ çš„ ğ‘‘ğ‘“ğ‘›
æ›´å°çš„èŠ‚ç‚¹ï¼Œé‚£ä¹ˆ (ğ‘¢,ğ‘£)
å°±ä¸æ˜¯å‰²è¾¹ï¼Œä¸å–ç­‰å·çš„åŸå› æ˜¯å®ƒæ˜¯ä¸€æ¡è¾¹è€Œéä¸€ä¸ªèŠ‚ç‚¹ã€‚

ç°åœ¨å”¯ä¸€çš„é—®é¢˜å°±æ˜¯åˆ¤æ–­ä¸€æ¡è¾¹æ˜¯å¦ä¸ºéæ ‘è¾¹ï¼Œæˆ‘ä»¬ä¸èƒ½ç›´æ¥å°† ğ‘£â†’ğ‘¢ ï¼ˆ ğ‘¢ æ˜¯ ğ‘£
çš„çˆ¶äº²ï¼‰è¯†åˆ«æˆéæ ‘è¾¹ï¼Œè¿™æ ·å¯èƒ½å°†æ ‘è¾¹ä¹Ÿè¯†åˆ«æˆéæ ‘è¾¹ã€‚

tarjan

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include<bits/stdc++.h>
#define int long long
const int N=1e6+1;
using namespace std;
struct fy
{
    int v,next;
}edge[N];
struct fy_
{
    int from,to;
}E[N];
int dfn[N],low[N],n,m,x,y,idx,head[N],res,cnt,IDX;
bool g[N];
inline void add(int x,int y)
{
    edge[++cnt].v=y,edge[cnt].next=head[x],head[x]=cnt;
}
inline void dfs(int u,int fa)
{
    dfn[u]=low[u]=++idx;
    for(int i=head[u];i;i=edge[i].next)
    {
        int v=edge[i].v;
        if(!dfn[v])
        {
            dfs(v,u);
            low[u]=min(low[u],low[v]);
            if(low[v]>dfn[u])
                E[++IDX].from=min(u,v),E[IDX].to=max(u,v);
        }
        else if(v!=fa&&dfn[v]<dfn[u])
            low[u]=min(low[u],dfn[v]);
    }
}
signed main()
{
    scanf("%lld%lld",&n,&m);
    for(int i=1;i<=m;i++)
    {
        scanf("%lld%lld",&x,&y);
        add(x,y),add(y,x);
    }
    dfs(1,-1);
    for(int i=1;i<=IDX;i++)
        printf("%lld %lld\n",E[i].from,E[i].to);
}
\end{minted}

æ ‘ä¸Šå·®åˆ†

å¯¹äºæ¯ä¸€æ¡éæ ‘è¾¹ï¼Œåœ¨å…¶æ ‘ä¸Šæ·±åº¦è¾ƒå°çš„ç‚¹å¤„æ‰“ä¸Š \texttt{-1}
æ ‡è®°ï¼Œåœ¨å…¶æ ‘ä¸Šæ·±åº¦è¾ƒå¤§çš„ç‚¹å¤„æ‰“ä¸Š \texttt{+1}
æ ‡è®°ã€‚ç„¶åæ±‚å‡ºæ¯ä¸ªç‚¹çš„å­æ ‘å†…éƒ¨çš„æ ‡è®°ä¹‹å’Œã€‚å¯¹äºä¸€ä¸ªç‚¹uï¼Œå…¶å­æ ‘å†…éƒ¨çš„æ ‡è®°ä¹‹å’Œç­‰äºè¦†ç›–äº†
uå’Œuçš„çˆ¶äº²ä¹‹é—´çš„æ ‘è¾¹çš„éæ ‘è¾¹æ•°é‡ã€‚è‹¥è¿™ä¸ªå€¼é0ï¼Œåˆ™uå’Œuçš„çˆ¶äº²ä¹‹é—´çš„æ ‘è¾¹ä¸æ˜¯æ¡¥ï¼Œå¦åˆ™æ˜¯æ¡¥ã€‚

\hypertarget{ux53ccux8054ux901aux5206ux91cf}{%
\subsection{åŒè”é€šåˆ†é‡}\label{ux53ccux8054ux901aux5206ux91cf}}

åŒè¿é€šåˆ†é‡åˆ†ä¸º\textbf{ç‚¹åŒè¿é€šåˆ†é‡}å’Œ\textbf{è¾¹åŒè¿é€šåˆ†é‡}ã€‚

è¾¹åŒè¿é€šå…·æœ‰ä¼ é€’æ€§ï¼Œç‚¹åŒè¿é€š \textbf{ä¸} å…·æœ‰ä¼ é€’æ€§

\begin{itemize}
\item
  ç‚¹åŒè¿é€šå›¾ï¼š\textbf{ä¸å­˜åœ¨å‰²ç‚¹çš„æ— å‘è¿é€šå›¾}æˆ‘ä»¬ç§°ä¸º\textbf{ç‚¹åŒè”é€šå›¾}ã€‚
\item
  è¾¹åŒè¿é€šå›¾ï¼š\textbf{ä¸å­˜åœ¨å‰²è¾¹çš„æ— å‘è¿é€šå›¾}æˆ‘ä»¬ç§°ä¸º\textbf{è¾¹åŒè”é€šå›¾}ã€‚
\item
  ç‚¹åŒè¿é€šåˆ†é‡ï¼ˆç‚¹åŒï¼‰ï¼šä¸€å¼ å›¾çš„æå¤§ç‚¹åŒè¿é€šå­å›¾ç§°ä¸º\textbf{ç‚¹åŒè¿é€šåˆ†é‡ï¼ˆV-BCCï¼‰ã€‚}
\item
  è¾¹åŒè¿é€šåˆ†é‡ï¼ˆè¾¹åŒï¼‰ï¼šä¸€å¼ å›¾çš„æå¤§è¾¹åŒè¿é€šå­å›¾ç§°ä¸º\textbf{è¾¹åŒè¿é€šåˆ†é‡ï¼ˆE-BCCï¼‰}ã€‚
\item
  ç‚¹åŒè¿é€šï¼šè‹¥ä¸¤ç‚¹ ğ‘¢,ğ‘£ åœ¨åŒä¸€ä¸ªç‚¹åŒè¿é€šåˆ†é‡å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§° ğ‘¢,ğ‘£ ç‚¹åŒè¿é€šã€‚
\item
  è¾¹åŒè”é€šï¼šè‹¥ä¸¤ç‚¹ ğ‘¢,ğ‘£ åœ¨åŒä¸€ä¸ªè¾¹åŒè¿é€šåˆ†é‡å†…ï¼Œé‚£ä¹ˆæˆ‘ä»¬ç§° ğ‘¢,ğ‘£ è¾¹åŒè¿é€šã€‚

  åœ¨ä¸€å¼ æ— å‘å›¾ä¸­ï¼Œå¦‚æœ (ğ‘¢,ğ‘£) ç›´æ¥ç›¸è¿ï¼Œé‚£ä¹ˆ ğ‘¢,ğ‘£
  ç‚¹åŒè¿é€šï¼Œä½†ä¸ä¸€å®šè¾¹åŒè¿é€šã€‚

  åŒæ—¶ï¼ŒåŒè¿é€šåˆ†é‡è¿˜æœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ€§è´¨ï¼Œæˆ‘ä»¬å°†å¼ºè¿é€šåˆ†é‡ç¼©ç‚¹åå¯ä»¥å¾—åˆ°ä¸€ä¸ª
  \textbf{DAG}ï¼Œä½†æ˜¯åŒè¿é€šåˆ†é‡ç¼©ç‚¹ä¹‹åå¯ä»¥å¾—åˆ°\textbf{ä¸€æ£µæ ‘}ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬åœ¨è¿›é˜¶ä¸­è¦è®²çš„\textbf{åœ†æ–¹æ ‘}ã€‚
\end{itemize}

\hypertarget{ux8fb9ux53ccux8fdeux901aux5206ux91cf}{%
\subsubsection{è¾¹åŒè¿é€šåˆ†é‡}\label{ux8fb9ux53ccux8fdeux901aux5206ux91cf}}

è¾¹åŒè¿é€šåˆ†é‡äº‹å®ä¸Šå¾ˆå¥½æ±‚ã€‚

æˆ‘ä»¬åªéœ€å°†è¯¥æ— å‘å›¾çš„æ‰€æœ‰å‰²è¾¹åˆ å»ï¼Œæ•´å¼ å›¾å°±ä¼šåˆ†è£‚æˆ\textbf{å‰²è¾¹æ•°é‡+1}ä¸ªè”é€šå—ï¼Œè¿™äº›è”é€šå—å†…ä¸å­˜åœ¨å‰²è¾¹ï¼Œä¹Ÿå°±æ˜¯è¯¥å›¾åˆ†è£‚æˆäº†è‹¥å¹²ä¸ªè¾¹åŒè¿é€šåˆ†é‡ã€‚

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const ll Maxn=4e6+7;
struct edge1{
    ll u,v,Next;
}Edge[Maxn<<1];
ll n,m,tot=1,f[Maxn];
ll low[Maxn],dfn[Maxn],cnt,head[Maxn];
ll cl;
vector<ll>ans[Maxn];
bool flg[Maxn],vis[Maxn];
inline void add(ll u,ll v){
    Edge[++tot]=(edge1){u,v,head[u]},head[u]=tot;
}
void tarjan(ll u){
    dfn[u]=low[u]=++cnt;
    for(ll i=head[u];i;i=Edge[i].Next){
        if(i==(f[u]^1)) continue;
        ll v=Edge[i].v;
        if(!dfn[v]){
            f[v]=i;
            tarjan(v);
            low[u]=min(low[u],low[v]);
            if(low[v]>dfn[u]) flg[i]=flg[i^1]=1;
        }
        else low[u]=min(low[u],dfn[v]);
    }
}
void DFS(ll u){
    vis[u]=1;
    ans[cl].push_back(u);
    for(ll i=head[u];i;i=Edge[i].Next){
        if(!flg[i]&&!vis[Edge[i].v]){
            DFS(Edge[i].v);
        }
    }
}
int main(){
    scanf("%lld%lld",&n,&m);
    for(ll i=1,u,v;i<=m;i++) 
        scanf("%lld%lld",&u,&v),add(u,v),add(v,u); 
    for(ll i=1;i<=n;i++) if(!dfn[i]) tarjan(i);
    for(ll i=1;i<=n;i++) if(!vis[i]) ++cl,DFS(i);
    printf("%lld\n",cl);
    for(ll i=1;i<=cl;i++,puts("")){
        printf("%lld ",ans[i].size());
        for(auto j:ans[i]) printf("%lld ",j);
    }
    return 0;
}
\end{minted}

\hypertarget{ux70b9ux53ccux8fdeux901aux5206ux91cf}{%
\subsubsection{ç‚¹åŒè¿é€šåˆ†é‡}\label{ux70b9ux53ccux8fdeux901aux5206ux91cf}}

å¯¹äºä¸€ä¸ªç‚¹åŒï¼Œå®ƒåœ¨ DFS æœç´¢æ ‘ä¸­ ğ‘‘ğ‘“ğ‘›\emph{d\textbf{f}n}
å€¼æœ€å°çš„ç‚¹ä¸€å®šæ˜¯å‰²ç‚¹æˆ–è€…æ ‘æ ¹ã€‚

å½“è¿™ä¸ªç‚¹æ˜¯å‰²ç‚¹æ—¶ï¼Œå®ƒæ‰€å±çš„ç‚¹åŒå¿…å®šä¸å¯ä»¥å‘å®ƒçš„çˆ¶äº²æ–¹å‘åŒ…æ‹¬æ›´å¤šç‚¹ï¼Œå› ä¸ºä¸€æ—¦å›æº¯ï¼Œå®ƒå°±æˆä¸ºäº†æ–°çš„å­å›¾çš„ä¸€ä¸ªå‰²ç‚¹ï¼Œä¸æ˜¯ç‚¹åŒã€‚æ‰€ä»¥å®ƒåº”è¯¥å½’åˆ°å…¶ä¸­ä¸€ä¸ªæˆ–å¤šä¸ªå­æ ‘é‡Œçš„ç‚¹åŒä¸­ã€‚

å½“è¿™ä¸ªç‚¹æ˜¯æ ‘æ ¹æ—¶ï¼Œå®ƒçš„ ğ‘‘ğ‘“ğ‘›\emph{d\textbf{f}n}
å€¼æ˜¯æ•´æ£µæ ‘é‡Œæœ€å°çš„ã€‚å®ƒè‹¥æœ‰ä¸¤ä¸ªä»¥ä¸Šå­æ ‘ï¼Œé‚£ä¹ˆå®ƒæ˜¯ä¸€ä¸ªå‰²ç‚¹ï¼›å®ƒè‹¥åªæœ‰ä¸€ä¸ªå­æ ‘ï¼Œå®ƒä¸€å®šå±äºå®ƒçš„ç›´ç³»å„¿å­çš„ç‚¹åŒï¼Œå› ä¸ºåŒ…æ‹¬å®ƒï¼›å®ƒè‹¥æ˜¯ä¸€ä¸ªç‹¬ç«‹ç‚¹ï¼Œè§†ä½œä¸€ä¸ªå•ç‹¬çš„ç‚¹åŒã€‚

æ¢å¥è¯è¯´ï¼Œä¸€ä¸ªç‚¹åŒä¸€å®šåœ¨è¿™ä¸¤ç±»ç‚¹çš„å­æ ‘ä¸­ã€‚

æˆ‘ä»¬ç”¨æ ˆç»´æŠ¤ç‚¹ï¼Œå½“é‡åˆ°è¿™ä¸¤ç±»ç‚¹æ—¶ï¼Œå°†å­æ ‘å†…ç›®å‰ä¸å±äºå…¶å®ƒç‚¹åŒçš„éå‰²ç‚¹æˆ–åœ¨å­æ ‘ä¸­çš„å‰²ç‚¹å½’åˆ°ä¸€ä¸ªæ–°çš„ç‚¹åŒã€‚æ³¨æ„è¿™ä¸ªç‚¹å¯èƒ½è¿˜æ˜¯ä¸å…¶å®ƒç‚¹åŒçš„å…¬å…±ç‚¹ï¼Œæ‰€ä»¥ä¸èƒ½å°†å…¶å‡ºæ ˆã€‚

\begin{minted}[fontsize=\footnotesize,breaklines,linenos]{cpp}
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5, M = 4e6 + 5;
int cnt = 1, fir[N], nxt[M], to[M];
int s[M], top, bcc, low[N], dfn[N], idx, n, m;
vector<int> ans[N];
inline void tarjan(int u, int fa) {
    int son = 0;
    low[u] = dfn[u] = ++idx;
    s[++top] = u;
    for(int i = fir[u]; i; i = nxt[i]) {
        int v = to[i];
        if(!dfn[v]) {
            son++;
            tarjan(v, u);
            low[u] = min(low[u], low[v]);
            if(low[v] >= dfn[u]) {
                bcc++;
                while(s[top + 1] != v) ans[bcc].push_back(s[top--]);//å°†å­æ ‘å‡ºæ ˆ
                ans[bcc].push_back(u);//æŠŠå‰²ç‚¹/æ ‘æ ¹ä¹Ÿä¸¢åˆ°ç‚¹åŒé‡Œ
            }
        } else if(v != fa) low[u] = min(low[u], dfn[v]);
    }
    if(fa == 0 && son == 0) ans[++bcc].push_back(u);//ç‰¹åˆ¤ç‹¬ç«‹ç‚¹
}
inline void add(int u, int v) {
    to[++cnt] = v;
    nxt[cnt] = fir[u];
    fir[u] = cnt;
}
int main() {
    scanf("%d%d", &n, &m);
    for(int i = 1; i <= m; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        add(u, v), add(v, u);
    }
    for(int i = 1; i <= n; i++) {
        if(dfn[i]) continue;
        top = 0;
        tarjan(i, 0);
    }
    printf("%d\n", bcc);
    for(int i = 1; i <= bcc; i++) {
        printf("%d ", ans[i].size());
        for(int j : ans[i]) printf("%d ", j);
        printf("\n");
    }
    return 0;
}
\end{minted}

\end{document}
